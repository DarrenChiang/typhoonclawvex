#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Motor,  port1,           drive_left,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           drive_right,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           scissor_left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           scissor_right, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           bottom_left,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           bottom_right,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw_top,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm_top,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           test,          tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////PARAMETER///////////////////////////////////////////////////////////////////

//PID CONSTANTS
double straight_p = 0.1;
double default_pid_straight = 100;
double default_pid_turn = 100;

//Bottom claw motor values
int bottom_out = 100; 
int bottom_in = -100;


///////////////////////////////////////////////////////////PID/////////////////////////////////////////////////////////////////////////

void striaght(double t){
	double initial, difference=0;
	ClearTimer(T1);
	while(time1[T1] <= t){
		sensorValue[gyro] = 0;
		initial = sensorValue[gyro];
		difference = sensorValue[gyro]-initial;
		motor[drive_right] = default_pid_straight+difference*straight_p;//setting speed of motor, check if robot should turn
		motor[drive_left] = default_pid_straight+difference*straight_p;//setting speed of motor, check if robot should turn
	}
}

void turn(double degree){
	sensorValue[gyro] = 0;
	if (degree > 0){
		while(sensorValue[gyro] <= degree){
			motor[drive_right] = -1*default_pid_turn;
			motor[drive_left] = default_pid_turn;
		}
	}
	else{
		while(sensorValue[gyro] >= degree){
			motor[drive_right] = default_pid_turn;
			motor[drive_left] = -1*default_pid_turn;
		}
	}
}

//////////////////////////////////////////////////////////M0TION//////////////////////////////////////////////////////////////////////

void motion(){//motor controlled by one joystick
	float y = vexRT[Ch2]/2;//get joystick value
	//change to left side control 2017/11/10
	float x = vexRT[Ch1]/2;//get joystick value
	//change to left 2017/11/10
	y*=0.9;
	x*=0.9;
	float left_motor;//variable for speed of left motor
	float right_motor;//variable for speed of right motor
	float power, st;//power for speed to distribute, st for steering
	power = sqrt(x*x+y*y);//calculating power
	if(y>=0&&power!=0){//check joystick position of y
		st = x * 100/power;//set value for st
		if(x>=0){//check joystick position of x
			left_motor = power;//set speed
			right_motor = (1-0.02*st)*power;
		}
		else{
			right_motor = power;
			left_motor = (1+0.02*st)*power;
		}
	}
	if(y<=0&&power!=0){
		power*=-1;
		st = x * 100/power;
		if(x>=0){
			left_motor = (1+0.02*st)*power;
			right_motor = power;
		}
		else{
			right_motor = (1-0.02*st)*power;
			left_motor = power;
		}
	}
	if(x==0&&y==0){
		motor[drive_left] = 0;
		motor[drive_right] = 0;
	}
	motor[drive_left] = left_motor;//set speed for left motor
	motor[drive_right] = right_motor;//set speed for right motor
}

/////////////////////////////////////////////////////BOTTOM CLAW//////////////////////////////////////////////////////////////////////

void moveBottomClaw(){
	if(vexRT[Btn6UXmtr2]==1){
		//move bottom claw out
		motor[bottom_left]=bottom_out; 
		motor[bottom_right]=bottom_out;
	}else if(vexRT[Btn6DXmtr2]==1){
		//move bottom claw in
		motor[bottom_left]=bottom_in; 
		motor[bottom_right]=bottom_in;
	}else{
		//stop bottom claw
		motor[bottom_left]=0; 
		motor[bottom_right]=0;
	}
}

/////////////////////////////////////////////////////////MAIN/////////////////////////////////////////////////////////////////////////

task main()
{
	while(true){
	}
}
