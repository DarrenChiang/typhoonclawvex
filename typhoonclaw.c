#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Motor,  port1,           drive_left,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           drive_right,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           scissor_left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           scissor_right, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           bottom_left,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           bottom_right,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw_top,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm_top,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////PARAMETER///////////////////////////////////////////////////////////////////

//PID CONSTANTS
double straight_p = 0.1; 														//P constant for Straight_PID 
double default_pid_straight = 100; 												//Default motor value for PID_Straight  
double default_pid_turn = 100; 													//Default motor value for PID_Turn

//Bottom claw motor values
int bottom_out = 100; 
int bottom_in = -100;


///////////////////////////////////////////////////////////PID/////////////////////////////////////////////////////////////////////////


//PID_Straight
void striaght(double t){
	double initial, difference=0;
	ClearTimer(T1);
	while(time1[T1] <= t){
		sensorValue[gyro] = 0;
		initial = sensorValue[gyro];
		difference = sensorValue[gyro]-initial;
		motor[drive_right] = default_pid_straight+difference*straight_p; 		//Setting speed of motor accourding to the difference
		motor[drive_left] = default_pid_straight+difference*straight_p; 		//Setting speed of motor accourding to the difference
	}
}

//PID_Turn
void turn(double degree){
	sensorValue[gyro] = 0;
	if (degree > 0){ 															//Turn right
		while(sensorValue[gyro] <= degree){
			motor[drive_right] = -1*default_pid_turn;
			motor[drive_left] = default_pid_turn;
		}
	}
	else{ 																		//Turn left
		while(sensorValue[gyro] >= degree){
			motor[drive_right] = default_pid_turn;
			motor[drive_left] = -1*default_pid_turn;
		}
	}
}

//////////////////////////////////////////////////////////M0TION//////////////////////////////////////////////////////////////////////

void motion(){																	//Motor controlled by one joystick
	float y = vexRT[Ch2]/2;														//Get joystick value
	//Change to left side control 2017/11/10
	float x = vexRT[Ch1]/2;														//Get joystick value
	//Change to left 2017/11/10
	y*=0.9;
	x*=0.9;
	float left_motor;															//Variable for speed of left motor
	float right_motor;															//Variable for speed of right motor
	float power, st;															//Power for speed to distribute, st for steering
	power = sqrt(x*x+y*y);														//Calculating power
	if(y>=0&&power!=0){															//Check joystick position of y
		st = x * 100/power														//Set value for st
		if(x>=0){																//Check joystick position of x
			left_motor = power;//Set speed
			right_motor = (1-0.02*st)*power;
		}
		else{
			right_motor = power;
			left_motor = (1+0.02*st)*power;
		}
	}
	if(y<=0&&power!=0){
		power*=-1;
		st = x * 100/power;
		if(x>=0){
			left_motor = (1+0.02*st)*power;
			right_motor = power;
		}
		else{
			right_motor = (1-0.02*st)*power;
			left_motor = power;
		}
	}
	if(x==0&&y==0){
		motor[drive_left] = 0;
		motor[drive_right] = 0;
	}
	motor[drive_left] = left_motor;												//Set speed for left motor
	motor[drive_right] = right_motor;											//Set speed for right motor
}

/////////////////////////////////////////////////////BOTTOM CLAW//////////////////////////////////////////////////////////////////////

void moveBottomClaw(){
	if(vexRT[Btn6UXmtr2]==1){													//Move bottom claw out
		motor[bottom_left]=bottom_out; 
		motor[bottom_right]=bottom_out;
	}else if(vexRT[Btn6DXmtr2]==1){												//Move bottom claw in
		motor[bottom_left]=bottom_in; 
		motor[bottom_right]=bottom_in;
	}else{																		//Stop bottom claw
		motor[bottom_left]=0; 
		motor[bottom_right]=0;
	}
}

/////////////////////////////////////////////////////////MAIN/////////////////////////////////////////////////////////////////////////

task main()
{
	while(true){
	}
}
